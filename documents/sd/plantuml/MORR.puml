@startuml MORR
skinparam monochrome true
skinparam linetype ortho
skinparam classAttributeIconSize 0
!pragma useNewPackage

left to right direction
hide empty fields

package MORR {
    !startsub SHARED
    package SHARED #E6E6E6 {
        package Configuration <<Rectangle>> #BFBFBF {
            interface IConfiguration {
                + Parse(configuration:RawConfiguration) : void
            }

            class InvalidConfigurationException {
                + <<create>> InvalidConfigurationException()
                + <<create>> InvalidConfigurationException(message: string)
                + <<create>> InvalidConfigurationException(message: string, innerException: exception)
            }

            class RawConfiguration {
                + RawValue: string
                + <<create>> RawConfiguration(rawValue: string)
            }

            IConfiguration ..> RawConfiguration : "uses"
        }

        together {
            interface IModule {
                + Identifier : Guid <<get>>
                + IsActive : bool <<get>> <<set>>
                + Initialize() : void
            }
        }

        together {
            abstract class Event {
                + Timestamp : DateTime <<get>>
                + IssuingModule : Guid <<get>>
            }

            package Queue <<Rectangle>> #BFBFBF {
                interface "IDecodableEventQueue<T: Event>" {
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                }

                interface "IEncodableEventQueue<T: Event>" {
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                }

                interface "IReadOnlyEventQueue<T: Event>" {
                    + EventType: Type
                    + GetEvents() : IAsyncEnumerable<T: Event>
                }

                interface "ISupportDeserializationEventQueue<T: Event>" {
                    + EventType: Type
                    + Enqueue(event: object): void
                }

                abstract class "DecodableEventQueue<T: Event>" {
                    # <<create>> DecodableEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                    + Enqueue(event: T) : void
                }

                abstract class "EncodableEventQueue<T: Event>" {
                    # <<create>> EncodableEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                    + Enqueue(event: T) : void
                }

                abstract class "ReadOnlyEventQueue<T: Event>" {
                    # <<create>> ReadOnlyEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                    + Enqueue(event: T) : void
                }

                abstract class "SupportDeserializationEventQueue<T: Event>" {
                    # <<create>> SupportDeserializationEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + Enqueue(event: T) : void
                }

                abstract class "DefaultEventQueue<T: Event>" {
                    # <<create>> DefaultEventQueue(bufferCapacity: int, maxConsumers: uint?)
                }

                abstract class "DefaultEncodableEventQueue<T: Event>" {
                    # <<create>> DefaultEncodableEventQueue(bufferCapacity: int)
                }

                abstract class "DefaultDecodableEventQueue<T: Event>" {
                    # <<create>> DefaultDecodableEventQueue(bufferCapacity: int, maxConsumers: uint?)
                }

                abstract class "NonDeserializableEventQueue<T: Event>" {
                    # <<create>> NonDeserializableEventQueue(bufferCapacity: int, maxConsumers: uint?)
                }

                package StorageStrategy <<Rectangle>> #E6E6E6 {
                    class ChannelConsumingException {
                        + <<create>> ChannelConsumingException()
                        + <<create>> ChannelConsumingException(message: string)
                        + <<create>> ChannelConsumingException(message: string, innerException: exception)
                    }

                    interface "IEventQueueStorageStrategy<T: Event>" {
                        + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                        + Enqueue(event: T) : void
                    }

                    together {
                        abstract class "MultiConsumerChannelStrategy<T: Event>" {
                            # StartReceiving(maxChannelConsumers: uint?) : void
                            + GetEvents(token: CancellationToken) : IAsyncEnumerable<T: Event>
                            + Enqueue(event: T) : void
                            # {abstract} CreateOfferingChannel() : Channel<T: Event>
                            # {abstract} CreateReceivingChannel() : Channel<T: Event>
                        }

                        class "BoundedMultiConsumerChannelStrategy<T: Event>" {
                            + <<create>> BoundedMultiConsumerChannelStrategy(bufferCapacity: int, maxChannelConsumers: uint?)
                            # CreateOfferingChannel() : Channel<T: Event>
                            # CreateReceivingChannel() : Channel<T: Event>
                        }

                        class "UnboundedMultiConsumerChannelStrategy<T: Event>" {
                            + <<create>> UnboundedMultiConsumerChannelStrategy(maxChannelConsumers: uint?)
                            # CreateOfferingChannel() : Channel<T: Event>
                            # CreateReceivingChannel() : Channel<T: Event>
                        }

                        "IEventQueueStorageStrategies<T: Event>" <|.. "MultiConsumerChannelStrategy<T: Event>"
                        "MultiConsumerChannelStrategy<T: Event>" <|-- "BoundedMultiConsumerChannelStrategy<T: Event>"
                        "MultiConsumerChannelStrategy<T: Event>" <|-- "UnboundedMultiConsumerChannelStrategy<T: Event>"
                        "BoundedMultiConsumerChannelStrategy<T: Event>" ..> ChannelConsumingException: "throws"
                    }
                    
                    together {
                        abstract class "SingleConsumerChannelStrategy<T: Event>" {
                            # StartReceiving() : void
                            + GetEvents(token: CancellationToken) : IAsyncEnumerable<T: Event>
                            + Enqueue(event: T) : void
                            # {abstract} CreateChannel() : Channel<T: Event>
                        }

                        class "BoundedSingleConsumerChannelStrategy<T: Event>" {
                            + <<create>> BoundedSingleConsumerChannelStrategy(bufferCapacity: int)
                            # CreateChannel() : Channel<T: Event>
                        }

                        class "UnboundedSingleConsumerChannelStrategy<T: Event>" {
                            + <<create>> UnboundedSingleConsumerChannelStrategy()
                            # CreateChannel() : Channel<T: Event>
                        }

                        "IEventQueueStorageStrategies<T: Event>" <|.. "SingleConsumerChannelStrategy<T: Event>"
                        "SingleConsumerChannelStrategy<T: Event>" <|-- "BoundedSingleConsumerChannelStrategy<T: Event>"
                        "SingleConsumerChannelStrategy<T: Event>" <|-- "UnboundedSingleConsumerChannelStrategy<T: Event>"
                        "BoundedSingleConsumerChannelStrategy<T: Event>" ..> ChannelConsumingException : "throws"
                    }
                }

                "IEventQueueStorageStrategy<T: Event>" "1" *-- "ReadOnlyEventQueue<T: Event>"
                "IEventQueueStorageStrategy<T: Event>" "1" *-- "EncodableEventQueue<T: Event>"
                "IEventQueueStorageStrategy<T: Event>" "1" *-- "DecodableEventQueue<T: Event>"

                "BoundedMultiConsumerChannelStrategy<T: Event>" <.. "DefaultEventQueue<T: Event>" : "uses"
                "BoundedMultiConsumerChannelStrategy<T: Event>" <.. "NonDeserializableEventQueue<T: Event>" : "uses"
                "BoundedMultiConsumerChannelStrategy<T: Event>" <.. "DefaultDecodableEventQueue<T: Event>" : "uses"
                "BoundedSingleConsumerChannelStrategy<T: Event>" <.. "DefaultEncodableEventQueue<T: Event>" : "uses"

                ' EventQueue
                "IDecodableEventQueue<T: Event>" <|.. "DecodableEventQueue<T: Event>"
                "IEncodableEventQueue<T: Event>" <|.. "EncodableEventQueue<T: Event>"
                "IReadOnlyEventQueue<T: Event>" <|.. "ReadOnlyEventQueue<T: Event>"
                "ISupportDeserializationEventQueue<T: Event>" <|.. "SupportDeserializationEventQueue<T: Event>"
                "ReadOnlyEventQueue<T: Event>" <|-- "SupportDeserializationEventQueue<T: Event>"
                "SupportDeserializationEventQueue<T: Event>" <|-- "DefaultEventQueue<T: Event>"
                "EncodableEventQueue<T: Event>" <|-- "DefaultEncodableEventQueue<T: Event>"
                "DecodableEventQueue<T: Event>" <|-- "DefaultDecodableEventQueue<T: Event>"
                "ReadOnlyEventQueue<T: Event>" <|-- "NonDeserializableEventQueue<T: Event>"
            }
        }

        package Utility <<Rectangle>> #BFBFBF {
            class DirectoryPath {
                + <<create>> DirectoryPath(value: string)
                + ToString() : string
            }

            class FilePath {
                + <<create>> FilePath(value: string)
                +  ToString() : string
            }

            class GlobalHook {
                + {static} IsActive : bool <<get>> <<set>>
                + {static} AddListener(callback: RetrieveMessageCallBack, types: NativeMethods.MessageType[])
                + {static} RemoveListener(callback: RetrieveMessageCallBack, types: NativeMethods.MessageType[])
                + {static} FreeLibrary()
            }

            class NativeMethods {
                + {static} DoWin32MessageLoop()
                + {static} StopMessageLoop()
                + {static} IsKeyPressed(VirtualKeyCode virtualKeyCode)
                + {static} TrySetKeyboardHook(callback: LowLevelKeyboardProc, handle: IntPtr)
                + {static} GetClipboardText()
                + {static} GetAssociatedWindow()
            }

            class Utility {
                + {static} SetAndDispatch(variable: bool, value: bool, onTrue: Action, onFalse: Action)
                + {static} GetTypeFromAnyAssembly(type: string)
            }

            together {
                class HookLibraryException {
                    + <<create>> HookLibraryException()
                    + <<create>> HookLibraryException(message: string)
                }
            }

            GlobalHook ..> HookLibraryException : "throws"
            GlobalHook ..> NativeMethods : "uses"
        }
    }
    !endsub 

    !startsub CORE
    package "CORE" #E6E6E6 {
        interface IBootstrapper {
            + ComposeImports(object:object) : void
        }

        class Bootstrapper {
            + <<create> Bootstrapper()
            + ComposeImports(object:object) : void
        }

        class BootstrapperConventions {
            + {static} GetRegistrationBuilder() : RegistrationBuilder
        }

        package ConfigurationManagement <<Rectangle>> #BFBFBF {
            interface IConfigurationManager {
                + LoadConfiguration(path:FilePath) : void
            }

            class ConfigurationManager {
                + LoadConfiguration(path:FilePath) : void
            }

            class InvalidConfigurationException {
                + <<create>> InvalidConfigurationException()
                + <<create>> InvalidConfigurationException(message: string)
                + <<create>> InvalidConfigurationException(message: string, innerException: Exception)
            }

            IConfigurationManager <|.. ConfigurationManager
            ConfigurationManager ..> InvalidConfigurationException : "throws"
        }

        package Session <<Rectangle>> #BFBFBF {
            interface ISessionManager {
                + IsRecording : bool <<get>>
                + StartRecording() : void
                + StopRecording() : void
                + Process(files: IEnumerable<FilePath>) : void
            }

            class SessionManager {
                - videoCapture : IVideoCapture
                + IsRecording : bool <<get>> <<private set>>
                + StartRecording() : void
                + StopRecording() : void
                + Process(files: IEnumerable<FilePath>) : void
            }

            together {
                abstract class RecordingException {

                }

                class AlreadyRecordingException {

                }

                class NotRecordingException {

                }

                RecordingException <|-- AlreadyRecordingException
                RecordingException <|-- NotRecordingException
            }

            ISessionManager <|-- SessionManager
            SessionManager ..> AlreadyRecordingException : "throws"
            SessionManager ..> NotRecordingException : "throws
        }

        package Modules <<Rectangle>> #BFBFBF {
            interface IModuleManager {
                + InitializeModules() : void
                + NotifyModulesOnSessionStart() : void
                + NotifyModulesOnSessionStop() : void
            }

            class ModuleManager {
                + InitializeModules() : void
                + NotifyModulesOnSessionStart() : void
                + NotifyModulesOnSessionStop() : void
            }

            class GlobalModuleConfiguration {
                + Parse(RawConfiguration: configuration) : void
            }

            IModuleManager <|-- ModuleManager
            ModuleManager *-- "1" GlobalModuleConfiguration
        }

        package Data <<Rectangle>> #BFBFBF {
            together {
                class CaptureException {
                    + <<create>> CaptureException()
                    + <<create>> CaptureException(message: string)
                    + <<create>> CaptureException(message: string, innerException: Exception)
                }

                together {
                    class DirectXVideoSample {
                        + Surface : IDirect3DSurface <<get>> <<set>>
                    }

                    class VideoSample {

                    }

                    together {
                        class VideoCaptureException {
                            + <<create>> VideoCaptureException()
                            + <<create>> VideoCaptureException(message: string)
                            + <<create>> VideoCaptureException(message: string, innerException: Exception)
                        }

                        CaptureException <|-- VideoCaptureException
                    }

                    package Desktop <<Rectangle>> #E6E6E6 {
                        class DesktopCapture {
                            + IsActive : bool
                            + Identifier: Guid
                            + Initialize() : void
                            - StartCapture() : void
                            - StopCapture() : void
                        }

                        class DesktopCaptureConfiguration {
                            + Index: MonitorIndex <<get>> <<private set>>
                            + PromptUserForMonitorSelection: bool <<get>> <<private set>>
                            + Parse(RawConfiguration: configuration) : void
                        }

                        class VideoSampleProducer {
                            + <<create>> VideoSampleProducer()
                            + StartCapture(item: GraphicsCaptureItem) : void
                            + StopCapture() : void
                            + Dispose() : void
                        }

                        together {
                            class Direct3D11Helper {
                                ~ {static} CreateDevice(useWARP: bool) : IDirect3DDevice?
                                ~ {static} CreateDirect3DSurfaceFromSharpDXTexture(texture: Texture2D) : IDirect3DSurface?
                                ~ {static} CreateSharpDXDevice(device: IDirect3DDevice) : Device?
                                ~ {static} CreateSharpDXTexture2D(surface: IDirect3DSurface) : Texture2D?
                            }

                            class GraphicsCaptureHelper {
                                ~ {static} CanCreateItemWithoutPicker: bool <<get>>
                                ~ {static} SetWindow(picker: GraphicsCapturePicker, hWnd: IntPtr) : void
                                ~ {static} CreateItemForMonitor(hMon: IntPtr) : GraphicsCaptureItem?
                            }

                            class MonitorInfo {
                                + IsPrimary: bool <<get>> <<set>>
                                + ScreenSize: Vector2 <<get>> <<set>>
                                + MonitorArea: Rect <<get>> <<set>>
                                + WorkArea: Rect <<get>> <<set>>
                                + DeviceName: string <<get>> <<set>>
                                + Hmon: IntPtr <<get>> <<set>>
                            }

                            class MonitorEnumerationHelper {
                                + {static} GetMonitors() : IEnumerable<MonitorInfo>
                            }

                            MonitorEnumerationHelper ..> MonitorInfo : "uses"
                        }

                        DesktopCapture --* "1 VideoSampleProducer" VideoSampleProducer
                        DesktopCapture --* "1 Configuration" DesktopCaptureConfiguration
                        DesktopCapture ..> MonitorEnumerationHelper : "uses"
                        VideoSampleProducer ..> Direct3D11Helper : "uses"
                    }

                    DesktopCapture ..> VideoCaptureException: "throws"
                    DirectXVideoSample --|> VideoSample
                }
            }

            together {
                class IntermediateFormatSample {
                    + Type : Type <<get>> <<set>>
                    + Data : byte[] <<get>> <<set>>
                }

                together {
                    class JsonIntermediateFormatDeserializer {
                        + IsActive: Bool <<get>> <<set>>
                        + Identifier: Guid <<get>>
                        + Initialize() : void
                    }

                    class JsonIntermediateFormatSample {
                        + JsonEncodedData: JsonDocument <<get>>
                        + JsonEncodedType: JsondEncodedText <<get>>
                    }

                    class JsonIntermediateFormatSerializer {
                        + IsActive: Bool <<get>> <<set>>
                        + Identifier: Guid <<get>>
                        + Initialize() : void
                    }
                }

                IntermediateFormatSample <|-- JsonIntermediateFormatSample
            }

            package Transcoding <<Rectangle>> #E6E6E6 {
                interface IDecoder {
                    + Decode(path: FilePath) : void
                }

                interface IEncoder {
                    + Encode(directoryRecordingPath: DirectoryPath) : void
                }

                package MPEG <<Rectangle>> #BFBFBF {
                    class MpegEncoder {
                        + Encode(directoryRecordingPath: DirectoryPath) : void
                    }
                    
                    class MpegEncoderConfiguration {
                        + Width: uint <<get>> <<set>>
                        + Height: uint <<get>> <<set>>
                        + KiloBitsPerSecond: uint <<get>> <<set>>
                        + FramesPerSecond: uint <<get>> <<set>>
                        + RecordingName: string <<get>> <<set>>
                        + Parse(RawConfiguration: configuration)
                    }
                }

                package Json <<Rectangle>> #BFBFBF {
                    class JsonDecoder {
                        + {static} Identifier: Guid <<get>>
                        + Decode(path: FilePath) : void
                    }

                    class JsonEncoder {
                        + Encode(directoryRecordingPath: DirectoryPath) : void
                    }
                }

                IEncoder <|.. MpegEncoder
                IDecoder <|.. JsonDecoder
                IEncoder <|-- JsonEncoder
                MpegEncoder --* "1 Configuration" MpegEncoderConfiguration
                MpegEncoder --* "1 VideoQueue" "IEncodableEventQueue<T: Event>"
            }
        }

        SessionManager --* "1" IEncoder
        SessionManager --* "0..1" IDecoder
        SessionManager --* "1" IModuleManager
        SessionManager ..> IBootstrapper : "uses"
        Bootstrapper ..> BootstrapperConventions : "uses"
        IBootstrapper <|.. Bootstrapper
    }
    !endsub

    VideoSample --|> Event
    DesktopCapture ..|> IModule
    DesktopCaptureConfiguration ..|> IConfiguration

    GlobalModuleConfiguration ..|> IConfiguration
    GlobalModuleConfiguration --* "* EnabledModules" IModule
    ModuleManager --* "* Modules" IModule

    IConfigurationManager --* "*" IConfiguration

    IntermediateFormatSample --|> Event
    JsonIntermediateFormatDeserializer ..|> IModule
    JsonIntermediateFormatDeserializer --* "* EventQueues" "ISupportDeserializationEventQueue<T: Event>"
    JsonIntermediateFormatDeserializer --* "1 IntermediateFormatSampleQueue" "IDecodableEventQueue<T: Event>"
    JsonIntermediateFormatSerializer ..|> IModule
    JsonIntermediateFormatSerializer --|> "DefaultEncodableEventQueue<T: Event>"
    JsonIntermediateFormatSerializer --* "* EventQueues" "IReadOnlyEventQueue<T: Event>"

    MpegEncoderConfiguration ..|> IConfiguration
    JsonDecoder --|> "DefaultDecodableEventQueue<T: Event>"
    JsonEncoder --* "1 IntermediateFormatSampleQueue" "IEncodableEventQueue<T: Event>"

    !startsub UI
    package "UI" #E6E6E6 {
        class ErrorDialog <<partial>> {
            + ErrorDialog(errorMessage:string)
            + ErrorMessage : string <<get>>
        }

        class InformationDialog <<partial>> {
            + InformationDialog()
        }

        class SaveDialog <<partial>> {
            + SaveDialog()
        }

        class ApplicationViewModel {
            + ApplicationViewModel()
            + IsRecording : bool <<get>> <<set>>
        }
        
        class NotifyIcon {
            + NotifyIcon()
            + Tooltip : string <<get>> <<set>>
            + CommandParameter : object <<get>> <<set>>
        }
        
        class RelayCommand {
            + RelayCommand(execute:Action<object>, canExecute:Predicate<object>?)
            + CanExecute(parameter:object) : bool
            + Execute(parameter:object) : void
        }

        interface ICommand {

        }

        class ContextMenu {

        }

        class ImageSource {

        }

        class App <<partial>> {

        }        
    }

    ' UI
    ApplicationViewModel --> "1" IRecordingManager : uses
    ApplicationViewModel o--> "n" ICommand
    App --> "1" ApplicationViewModel
    ApplicationViewModel o-> SaveDialog
    ApplicationViewModel o-> ErrorDialog
    ApplicationViewModel o-> InformationDialog
    App o-> NotifyIcon
    NotifyIcon --> "IconSource" ImageSource
    NotifyIcon --> "Command" ICommand
    NotifyIcon --> "ContextMenu" ContextMenu
    ICommand <|.. RelayCommand
    !endsub

    !startsub CLI
    package "CLI" #E6E6E6 {
        class Program {
            + {static} Main(args:string[]) : int
        }

        together {
            interface "ICommand<T: CommandOptions>" {
                + Execute(options: T) : int
            }

            abstract class CommandOptions {
                + IsVerbose: bool <<get>> <<set>>
            }

            together {
                class ProcessCommand {
                    + Execute(options: ProcessOptions) : int
                }

                class ProcessOptions {
                    + IsVerbose: bool <<get>> <<set>>
                    + ConfigPath: string <<get>> <<set>>
                    + InputFile: string <<get>> <<set>>
                }

                ProcessCommand ..> ProcessOptions : "uses"
            }

            together {
                class RecordCommand {
                    + Execute(options: RecordOptions) : int
                }

                class RecordOptions {
                    + IsVerbose: bool <<get>> <<set>>
                    + ConfigPath: string <<get>> <<set>>
                }

                RecordCommand ..> RecordOptions : "uses"
            }

            together {
                class ValidateCommand {
                    + Execute(options: ValidateOptions) : int
                }

                class ValidateOptions {
                    + IsVerbose: bool <<get>> <<set>>
                    + ConfigPath: string <<get>> <<set>>
                }

                ValidateCommand ..> ValidateOptions : "uses"
            }

            RecordCommand ..|> "ICommand<T: CommandOptions>"
            ValidateCommand ..|> "ICommand<T: CommandOptions>"
            ProcessCommand ..|> "ICommand<T: CommandOptions>"

            RecordOptions --|> CommandOptions
            ValidateOptions --|> CommandOptions
            ProcessOptions --|> CommandOptions
        }

        together {
            class InteractiveCommandLine {
                + Launch(cancelAction: Action) : void
            }
        }

        together {
            class IOutputFormatter {

            }

            class OutputFormatter {
                ~ IsVerbose: bool <<get>> <<set>>
                + Encode(path: DirectoryPath) : void
                ~ {static} PrintError(exception: Exception) : void
                ~ {static} PrintDebug(message: string) : void
            }

            OutputFormatter ..|> IOutputFormatter
        }

        ProcessCommand ..> OutputFormatter : "uses"
        ValidateCommand ..> OutputFormatter : "uses"
        RecordCommand ..> OutputFormatter : "uses"
        RecordCommand ..> InteractiveCommandLine :"uses"

        Program ..> ProcessCommand : "uses"
        Program ..> ValidateCommand : "uses"
        Program ..> RecordCommand : "uses"
    }
    !endsub

    ProcessCommand ..> ISessionManager : "uses"
    RecordCommand ..> ISessionManager : "uses"
    RecordCommand ..> NativeMethods : "uses"
    ValidateCommand ..> IBootstrapper : "uses"
    ValidateCommand ..> IModuleManager : "uses"
    IOutputFormatter --|> IEncoder
    OutputFormatter --* "1 MetadataQueue" "IEncodableEventQueue<T: Event>"

    package "MODULES" #E6E6E6 {
        !startsub MODULES_CLIPBOARD
        package "CLIPBOARD" #BFBFBF {
            class ClipboardModule {
            
            }

            abstract class ClipboardEvent {
            
            }

            class ClipBoardInteractEvent {
                + Text : string <<get>> <<set>>
            }

            enum InteractionType {
                CLEAR
                COPY
                CUT
                PASTE
            }
        }

        'Clipboard
        IModule <|.. ClipboardModule
        Event <|-- ClipboardEvent
        ClipboardEvent <|-- ClipBoardInteractEvent
        ClipBoardInteractEvent --> "Interaction" InteractionType
        ClipBoardInteractEvent +-- InteractionType
        !endsub

        !startsub MODULES_KEYBOARD
        package "KEYBOARD" #BFBFBF {
            class KeyboardModule {
            
            }

            abstract class KeyboardEvent {
            }
            
            class KeyBoardInteractEvent {
                + PressedKey: Key
            }
        }

        ' Keyboard
        Event <|-- KeyboardEvent
        IModule <|.. KeyboardModule
        KeyboardEvent <|-- KeyBoardInteractEvent
        !endsub

        !startsub MODULES_MOUSE
        package "MOUSE" #BFBFBF {
            class MouseModule {
        
            }

            
            abstract class MouseEvent {
            }

            class MouseMoveEvent {
                + Movement: Vector2
            }

            enum MouseButton {
                LEFT,
                CENTER,
                RIGHT
            }

            enum MouseButtonState {

            }
            
            class MouseClickEvent {
                + HWnd: IntPtr
            }
            
            class MouseScrollEvent {
                + HWnd: IntPtr
                + ScrollAmount : short <<get>> <<set>>
            }
        }

        ' Mouse
        Event <|-- MouseEvent
        IModule <|.. MouseModule
        MouseEvent <|-- MouseClickEvent
        MouseEvent <|-- MouseScrollEvent
        MouseEvent <|-- MouseMoveEvent
        MouseClickEvent --> "Button" MouseButton
        MouseClickEvent --> "State" MouseButtonState
        !endsub

        !startsub MODULES_WEBBROWSER
        package "WEBBROWSER" #BFBFBF {
            class WebBrowserModule {
        
            }

            class ButtonClickEvent {
                + Button : string <<get>> <<set>>
                + URL: Uri
            }
            
            class CloseTabEvent {
            }
            
            class FileDownloadEvent {
                + MIMEType : string <<get>> <<set>>
                + FileURL: Uri
            }
            
            class HoverEvent {
                + HoveredElement : string <<get>> <<set>>
            }
            class NavigationEvent {
            }
            
            class OpenTabEvent {
            }
            
            class SwitchTabEvent {
                + NewTabID: Guid
            }
            
            class TextInputEvent {
                + InputtedText : string <<get>> <<set>>
                + Textbox : string <<get>> <<set>>
            }
            
            class TextSelectionEvent {
                + SelectedText : string <<get>> <<set>>
            }
            
            abstract class WebBrowserEvent {
                + TabID: Guid
                + CurrentURL: Uri
            }
        }

        ' WebBrowser
        Event <|-- WebBrowserEvent
        IModule <|.. WebBrowserModule
        WebBrowserEvent <|-- ButtonClickEvent
        WebBrowserEvent <|-- CloseTabEvent
        WebBrowserEvent <|-- FileDownloadEvent
        WebBrowserEvent <|-- HoverEvent
        WebBrowserEvent <|-- NavigationEvent
        WebBrowserEvent <|-- OpenTabEvent
        WebBrowserEvent <|-- SwitchTabEvent
        WebBrowserEvent <|-- TextInputEvent
        WebBrowserEvent <|-- TextSelectionEvent
        !endsub

        !startsub MODULES_WINDOWMANAGEMENT
        package "WINDOWMANAGEMENT" #BFBFBF {
            class WindowManagementModule {
        
            }

            abstract class WindowEvent {
                + Title : string <<get>> <<set>>
                + ProcessName : string <<get>> <<set>>
            }
            
            class WindowFocusEvent {

            }

            class WindowMovementEvent {
                + OldLocation: Vector2
                + NewLocation: Vector2
            }

            class WindowResizingEvent {
                + OldSize: Size
                + NewSize: Size
            }

            class WindowStateChangedEvent {
                + State: WindowState
            }
        }

        ' WindowManagement
        Event <|-- WindowEvent
        IModule <|.. WindowManagementModule
        WindowEvent <|-- WindowFocusEvent
        WindowEvent <|-- WindowMovementEvent
        WindowEvent <|-- WindowResizingEvent
        WindowEvent <|-- WindowStateChangedEvent
        !endsub
    }
}
@enduml
