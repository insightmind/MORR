@startuml MORR
skinparam monochrome true
skinparam linetype ortho
skinparam classAttributeIconSize 0
!pragma useNewPackage

left to right direction
hide empty fields

package MORR {
    !startsub SHARED
    package SHARED #E6E6E6 {
        package Configuration <<Rectangle>> {
            interface IConfiguration {
                + Parse(configuration:RawConfiguration) : void
            }

            class InvalidConfigurationException {
                + <<create>> InvalidConfigurationException()
                + <<create>> InvalidConfigurationException(message: string)
                + <<create>> InvalidConfigurationException(message: string, innerException: exception)
            }

            class RawConfiguration {
                + RawValue: string
                + <<create>> RawConfiguration(rawValue: string)
            }

            IConfiguration ..> RawConfiguration : "uses"
        }

        package Modules <<Rectangle>> {
            interface IModule {
                + Identifier : Guid <<get>>
                + IsActive : bool <<get>> <<set>>
                + Initialize() : void
            }
        }

        package Events <<Rectangle>> {
            abstract class Event {
                + Timestamp : DateTime <<get>>
                + IssuingModule : Guid <<get>>
            }

            package Queue <<Rectangle>> {
                interface "IDecodableEventQueue<T: Event>" {
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                }

                interface "IEncodableEventQueue<T: Event>" {
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                }

                interface "IReadOnlyEventQueue<T: Event>" {
                    + EventType: Type
                    + GetEvents() : IAsyncEnumerable<T: Event>
                }

                interface "ISupportDeserializationEventQueue<T: Event>" {
                    + EventType: Type
                    + Enqueue(event: object): void
                }

                abstract class "DecodableEventQueue<T: Event>" {
                    # <<create>> DecodableEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                    + Enqueue(event: T) : void
                }

                abstract class "EncodableEventQueue<T: Event>" {
                    # <<create>> EncodableEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                    + Enqueue(event: T) : void
                }

                abstract class "ReadOnlyEventQueue<T: Event>" {
                    # <<create>> ReadOnlyEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                    + Enqueue(event: T) : void
                }

                abstract class "SupportDeserializationEventQueue<T: Event>" {
                    # <<create>> SupportDeserializationEventQueue(storageStrategy: IEventQueueStorageStrategy<T: Event>)
                    + Enqueue(event: T) : void
                }

                abstract class "DefaultEventQueue<T: Event>" {
                    # <<create>> DefaultEventQueue(bufferCapacity: int, maxConsumers: uint?)
                }

                abstract class "DefaultEncodableEventQueue<T: Event>" {
                    # <<create>> DefaultEncodableEventQueue(bufferCapacity: int)
                }

                abstract class "DefaultDecodableEventQueue<T: Event>" {
                    # <<create>> DefaultDecodableEventQueue(bufferCapacity: int)
                }

                abstract class "NonDeserializableEventQueue<T: Event>" {
                    # <<create>> NonDeserializableEventQueue(bufferCapacity: int, maxConsumers: uint?)
                }

                package Strategy <<Rectangle>> {
                    class ChannelConsumingException {
                        + <<create>> ChannelConsumingException()
                        + <<create>> ChannelConsumingException(message: string)
                        + <<create>> ChannelConsumingException(message: string, innerException: exception)
                    }

                    interface "IEventQueueStorageStrategy<T: Event>" {
                        + GetEvents(cancellationToken: CancellationToken) : IAsyncEnumerable<T: Event>
                        + Enqueue(event: T) : void
                    }

                    package MultiConsumer <<Rectangle>> {
                        abstract class "MultiConsumerChannelStrategy<T: Event>" {
                            # StartReceiving(maxChannelConsumers: uint?) : void
                            + GetEvents(token: CancellationToken) : IAsyncEnumerable<T: Event>
                            + Enqueue(event: T) : void
                            # abstract CreateOfferingChannel() : Channel<T: Event>
                            # abstract CreateReceivingChannel() : Channel<T: Event>
                        }

                        class "BoundedMultiConsumerChannelStrategy<T: Event>" {
                            + <<create>> BoundedMultiConsumerChannelStrategy(bufferCapacity: int, maxChannelConsumers: uint?)
                            # CreateOfferingChannel() : Channel<T: Event>
                            # CreateReceivingChannel() : Channel<T: Event>
                        }

                        class "UnboundedMultiConsumerChannelStrategy<T: Event>" {
                            + <<create>> UnboundedMultiConsumerChannelStrategy(maxChannelConsumers: uint?)
                            # CreateOfferingChannel() : Channel<T: Event>
                            # CreateReceivingChannel() : Channel<T: Event>
                        }

                        "IEventQueueStorageStrategies<T: Event>" <|.. "MultiConsumerChannelStrategy<T: Event>"
                        "MultiConsumerChannelStrategy<T: Event>" <|-- "BoundedMultiConsumerChannelStrategy<T: Event>"
                        "MultiConsumerChannelStrategy<T: Event>" <|-- "UnboundedMultiConsumerChannelStrategy<T: Event>"
                        "BoundedMultiConsumerChannelStrategy<T: Event>" ..> ChannelConsumingException: "throws"
                    }
                    
                    package SingleConsumer <<Rectangle>> {
                        abstract class "SingleConsumerChannelStrategy<T: Event>" {
                            # StartReceiving() : void
                            + GetEvents(token: CancellationToken) : IAsyncEnumerable<T: Event>
                            + Enqueue(event: T) : void
                            # abstract CreateChannel() : Channel<T: Event>
                        }

                        class "BoundedSingleConsumerChannelStrategy<T: Event>" {
                            + <<create>> BoundedSingleConsumerChannelStrategy(bufferCapacity: int)
                            # CreateChannel() : Channel<T: Event>
                        }

                        class "UnboundedSingleConsumerChannelStrategy<T: Event>" {
                            + <<create>> UnboundedSingleConsumerChannelStrategy()
                            # CreateChannel() : Channel<T: Event>
                        }

                        "IEventQueueStorageStrategies<T: Event>" <|.. "SingleConsumerChannelStrategy<T: Event>"
                        "SingleConsumerChannelStrategy<T: Event>" <|-- "BoundedSingleConsumerChannelStrategy<T: Event>"
                        "SingleConsumerChannelStrategy<T: Event>" <|-- "UnboundedSingleConsumerChannelStrategy<T: Event>"
                        "BoundedSingleConsumerChannelStrategy<T: Event>" ..> ChannelConsumingException : "throws"
                    }
                }

                "IEventQueueStorageStrategy<T: Event>" "1" *-- "ReadOnlyEventQueue<T: Event>"
                "IEventQueueStorageStrategy<T: Event>" "1" *-- "EncodableEventQueue<T: Event>"
                "IEventQueueStorageStrategy<T: Event>" "1" *-- "DecodableEventQueue<T: Event>"

                "BoundedMultiConsumerChannelStrategy<T: Event>" <.. "DefaultEventQueue<T: Event>" : "uses"
                "BoundedMultiConsumerChannelStrategy<T: Event>" <.. "NonDeserializableEventQueue<T: Event>" : "uses"
                "BoundedSingleConsumerChannelStrategy<T: Event>" <.. "DefaultDecodableEventQueue<T: Event>" : "uses"
                "BoundedSingleConsumerChannelStrategy<T: Event>" <.. "DefaultEncodableEventQueue<T: Event>" : "uses"

                ' EventQueue
                "IDecodableEventQueue<T: Event>" <|.. "DecodableEventQueue<T: Event>"
                "IEncodableEventQueue<T: Event>" <|.. "EncodableEventQueue<T: Event>"
                "IReadOnlyEventQueue<T: Event>" <|.. "ReadOnlyEventQueue<T: Event>"
                "ISupportDeserializationEventQueue<T: Event>" <|.. "SupportDeserializationEventQueue<T: Event>"
                "ReadOnlyEventQueue<T: Event>" <|-- "SupportDeserializationEventQueue<T: Event>"
            }
        }
    }
    !endsub 

    !startsub CORE
    package "CORE" #E6E6E6 {
        interface IRecordingManager {
            + IsRecording : bool <<get>>
            + StartRecording() : void
            + StopRecording() : void
            + StartDecoding() : void
            + StopDecoding() : void
        }

        class RecordingManager {
            - encoder : IEncoder
            - decoder : IDecoder
            - videoCapture : IVideoCapture
            + IsRecording : bool <<get>> <<private set>>
            + EventQueues : IEnumerable<EventQueue<Event>> <<get>> <<private set>>
            + StartRecording() : void
            + StopRecording() : void
            + StartDecoding() : void
            + StopDecoding() : void
        }

        interface IModuleManager {
            + Modules : IEnumerable<IModule> <<get>>
            + CollectingModules : IEnumerable<ICollectingModule> <<get>>
            + ModuleConfiguration : GlobalModuleConfiguration <<get>>
            + InitializeModules() : void
        }

        class ModuleManager {
            + Modules : IEnumerable<IModule> <<get>> <<private set>>
            + CollectingModules : IEnumerable<ICollectingModule> <<get>> <<private set>>
            + ModuleConfiguration : GlobalModuleConfiguration <<get>> <<private set>>
            + InitializeModules() : void
        }

        interface IBootstrapper {
            + ComposeImports(@object:object) : void
        }

        class Bootstrapper {
            + ComposeImports(@object:object) : void
        }

        interface IConfigurationManager {
            + LoadConfiguration(path:string) : void
            + Configurations : IEnumerable<IConfiguration> <<get>>
        }

        class ConfigurationManager {
            + LoadConfiguration(path:string) : void
            + Configurations : IEnumerable<IConfiguration> <<get>> <<private set>>
        }

        class GlobalModuleConfiguration {
            + EnabledModules : IEnumerable<Type> <<get>> <<set>>
            + Parse(string configuration) : void
        }

        class RecordingException {
        }

        class AlreadyRecordingException {
        }

        class NotRecordingException {
        }

        package "CAPTURE" #BFBFBF {
            interface IVideoCapture {
                + NextSample() : VideoSample
            }

            class DesktopCapture {
                + CaptureConfiguration : DesktopCaptureConfiguration <<get>> <<set>>
                + NextSample() : VideoSample
            }

            class DesktopCaptureConfiguration {
                + DeviceToRecord : string <<get>> <<set>>
                + Parse(string configuration) : void
            }

            class CaptureHelper {
                + {static} CanCreateItemWithoutPicker : bool
                + {static} CreateItemForMonitor(IntPtr hMon) : GraphicsCaptureItem
            }

            class Direct3D11Helper {
                + {static} CreateDevice(bool useWARP = false) : IDirect3DDevice
                + {static} CreateDirect3DSurfaceFromSharpDXTexture(Texture2D texture) : IDirect3DSurface
                + {static} CreatesharpDXDevice(IDirect3DDevice device) : Device
                + {static} CreateSharpDXTexture2D(IDirect3DSurface surface) : Texture2D
            }

            class MonitorInfo {
                + IsPrimary : bool <<get>> <<set>>
                + ScreenSize : Vector2 <<get>> <<set>>
                + MonitorArea : Rect <<get>> <<set>>
                + WorkArea : Rect <<get>> <<set>>
                + DeviceName : string <<get>> <<set>>
                + HMon : IntPtr <<get>> <<set>>
            }

            class MonitorEnumerationHelper {
                + {static} GetMonitors() : IEnumerable<MonitorInfo>
            }

            class CaptureException {
            }

            class VideoCaptureException {
            }

            interface IMetadataCapture {
                + NextSample() : MetadataSample
            }

            class MetadataCapture {
                + EventQueues : IEnumerable<EventQueue<Event>> <<get>> <<private set>>
                + NextSample() : MetadataSample
            }
        }

        package "TRANSCODING" #BFBFBF {
            package "MPEG" #8F8F8F {
                class MPEGDecoder {
                    + Decode(string path) : void <<throws DecodingException>>
                    + DecoderConfiguration : MPEGDecoderConfiguration <<get>> <<set>>
                    + <<event>> VideoSampleDecoded : VideoSampleDecodedEventHandler 
                    + <<event>> MetadataSampleDecoded : MetadataSampleDecodedEventHandler 
                }

                class MPEGDecoderConfiguration {
                    + ShouldExtractVideo : bool <<get>> <<set>>
                    + Parse(string configuration) : void
                }

                class MPEGEncoder {
                    + Encode() : void <<throws EncodingException>>
                    + EncoderConfiguration : MPEGEncoderConfiguration <<get>> <<set>>
                    + <<event>> VideoSampleRequested : VideoSampleRequestedEventHandler 
                    + <<event>> MetadataSampleRequested : MetadataSampleRequestedEventHandler 
                }

                class MPEGEncoderConfiguration {
                    + Bitrate : ushort <<get>> <<set>>
                    + Framerate : byte <<get>> <<set>>
                    + Resolution : Size <<get>> <<set>>
                    + Directory : string <<get>> <<set>>
                    + Parse(string configuration) : void
                }
            }

            package "CSV" #8F8F8F {
                class CSVEncoder {
                    + Encode() : void <<throws EncodingException>>
                    + <<event>> MetadataSampleRequested : MetadataSampleRequestedEventHandler 
                }
            } 

            abstract class MetadataSample {
            }

            abstract class VideoSample {
            }

            class VideoDecodingException {
            }

            class MetadataDecodingException {
            }

            class VideoEncodingException {
            }

            class MetadataEncodingException {
            }

            class DecodingException {
            }

            class EncodingException {
            }

            "Func<VideoSample, void>" <|-- VideoSampleDecodedEventHandler

            "Func<VideoSample?>" <|-- VideoSampleRequestedEventHandler

            "Func<MetadataSample, void>" <|-- MetadataSampleDecodedEventHandler

            "Func<MetadataSample?>" <|-- MetadataSampleRequestedEventHandler

            interface IMetadataDeserializer {
            }

            class MetadataDeserializer {
                + EventQueues : IEnumerable<EventQueue<Event>> <<get>> <<private set>>
            }

            interface IDecoder {
                + Decode(string path) : void <<throws DecodingException>>
                + <<event>> VideoSampleDecoded : VideoSampleDecodedEventHandler 
                + <<event>> MetadataSampleDecoded : MetadataSampleDecodedEventHandler 
            }
        
            interface IEncoder {
                + Encode(string path) : void <<throws EncodingException>>
                + <<event>> VideoSampleRequested : VideoSampleRequestedEventHandler 
                + <<event>> MetadataSampleRequested : MetadataSampleRequestedEventHandler 
            }

            class DecodingException {
            }

            class EncodingException {
            }
        }
    }

    ' CORE

    Exception <|-- RecordingException
    RecordingException <|-- AlreadyRecordingException
    RecordingException <|-- NotRecordingException

    Exception <|-- InvalidConfigurationException
    IBootstrapper <|-- Bootstrapper

    IConfigurationManager <|.. ConfigurationManager
    IConfiguration <|.. GlobalModuleConfiguration
    IModuleManager <|.. ModuleManager
    IRecordingManager <|.. RecordingManager

    Exception <|.. CaptureException

    IVideoCapture <|.. DesktopCapture
    IConfiguration <|.. DesktopCaptureConfiguration

    CaptureException <|-- VideoCaptureException

    IReceivingModule <|.. IMetadataCapture
    IMetadataCapture <|.. MetadataCapture

    IEncoder <|.. CSVEncoder

    Exception <|-- DecodingException
    Exception <|-- EncodingException

    DecodingException <|-- MetadataDecodingException
    EncodingException <|-- MetadataEncodingException

    IMetadataDeserializer <|.. MetadataDeserializer

    DecodingException <|-- VideoDecodingException
    EncodingException <|-- VideoEncodingException

    IDecoder <|.. MPEGDecoder
    IEncoder <|.. MPEGEncoder

    IConfiguration <|.. MPEGDecoderConfiguration
    IConfiguration <|.. MPEGEncoderConfiguration

    ConfigurationManager --> "*" IConfiguration
    ConfigurationManager --> InvalidConfigurationException : throws
    ModuleManager --> "*" IModule
    ModuleManager --> "*" ICollectingModule

    RecordingManager --> "encoder" IEncoder
    RecordingManager --> "decoder" IDecoder
    RecordingManager --> "videoCapture" DesktopCapture
    RecordingManager --> "metadataCapture" MetadataCapture
    RecordingManager --> "metadataDeserializer" MetadataDeserializer
    RecordingManager --> "ConfigurationManager" ConfigurationManager
    RecordingManager --> "ModuleManager" ModuleManager
    RecordingManager ..> IBootstrapper : uses

    ' Transcoding
    IDecoder ..> MetadataSample : uses
    IEncoder ..> MetadataSample : uses
    IVideoCapture ..> VideoSample : <<creates>>
    IVideoCapture ..> VideoCaptureException : throws >

    ' MPEG
    DesktopCapture ..> Direct3D11Helper : uses
    DesktopCapture ..> CaptureHelper : uses

    MPEGEncoder ..> DesktopCapture : uses
    MPEGEncoder ..> MonitorEnumerationHelper : uses
    MonitorEnumerationHelper ..> MonitorInfo : uses
    !endsub

    !startsub UI
    package "UI" #E6E6E6 {
        class ErrorDialog <<partial>> {
            + ErrorDialog(errorMessage:string)
            + ErrorMessage : string <<get>>
        }

        class InformationDialog <<partial>> {
            + InformationDialog()
        }

        class SaveDialog <<partial>> {
            + SaveDialog()
        }

        class ApplicationViewModel {
            + ApplicationViewModel()
            + IsRecording : bool <<get>> <<set>>
        }
        
        class NotifyIcon {
            + NotifyIcon()
            + Tooltip : string <<get>> <<set>>
            + CommandParameter : object <<get>> <<set>>
        }
        
        class RelayCommand {
            + RelayCommand(execute:Action<object>, canExecute:Predicate<object>?)
            + CanExecute(parameter:object) : bool
            + Execute(parameter:object) : void
        }

        interface ICommand {

        }

        class ContextMenu {

        }

        class ImageSource {

        }

        class App <<partial>> {

        }        
    }

    ' UI
    ApplicationViewModel --> "1" IRecordingManager : uses
    ApplicationViewModel o--> "n" ICommand
    App --> "1" ApplicationViewModel
    ApplicationViewModel o-> SaveDialog
    ApplicationViewModel o-> ErrorDialog
    ApplicationViewModel o-> InformationDialog
    App o-> NotifyIcon
    NotifyIcon --> "IconSource" ImageSource
    NotifyIcon --> "Command" ICommand
    NotifyIcon --> "ContextMenu" ContextMenu
    ICommand <|.. RelayCommand
    !endsub

    !startsub CLI
    package "CLI" #E6E6E6 {
        class Program {
            {static} Main(args:string[]) : void
        }
        
        class Options {

        }

        interface ICLICommand {
            + ExecuteCommand(options: Options)
        }

        class ProcessOptions {
            + Input : string
            + Output : string
            + ProcessingEnabled: bool
            + Verbose: bool
        }
    
        class OutputFormatter {
            + PrintMessage(message: string, verbose: bool) : void
            + PrintException(exception: Exception) : void
        }
    
        class ProcessCommand {
            + ProcessCommand(recordingManager : IRecordingManager)
            + ExecuteCommand(options: ProcessOptions)
        }
    }

    ' CLI
    IRecordingManager <-- ProcessCommand
    Program --> IRecordingManager

    Program --> "1" OutputFormatter
    Program o--> ICLICommand
    ICLICommand ..> Options : uses
    ICLICommand <|.. ProcessCommand
    Options <|-- ProcessOptions
    ProcessCommand ..> ProcessOptions: uses
    !endsub

    package "MODULES" #E6E6E6 {
        !startsub MODULES_CLIPBOARD
        package "CLIPBOARD" #BFBFBF {
            class ClipboardModule {
            
            }

            abstract class ClipboardEvent {
            
            }

            class ClipBoardInteractEvent {
                + Text : string <<get>> <<set>>
            }

            enum InteractionType {
                CLEAR
                COPY
                CUT
                PASTE
            }
        }

        'Clipboard
        ICollectingModule <|.. ClipboardModule
        Event <|-- ClipboardEvent
        ClipboardEvent <|-- ClipBoardInteractEvent
        ClipBoardInteractEvent --> "Interaction" InteractionType
        ClipBoardInteractEvent +-- InteractionType
        !endsub

        !startsub MODULES_KEYBOARD
        package "KEYBOARD" #BFBFBF {
            class KeyboardModule {
            
            }

            abstract class KeyboardEvent {
            }
            
            class KeyBoardInteractEvent {
                + PressedKey: Key
            }
        }

        ' Keyboard
        Event <|-- KeyboardEvent
        ICollectingModule <|.. KeyboardModule
        KeyboardEvent <|-- KeyBoardInteractEvent
        !endsub

        !startsub MODULES_MOUSE
        package "MOUSE" #BFBFBF {
            class MouseModule {
        
            }

            
            abstract class MouseEvent {
            }

            class MouseMoveEvent {
                + Movement: Vector2
            }

            enum MouseButton {
                LEFT,
                CENTER,
                RIGHT
            }

            enum MouseButtonState {

            }
            
            class MouseClickEvent {
                + HWnd: IntPtr
            }
            
            class MouseScrollEvent {
                + HWnd: IntPtr
                + ScrollAmount : short <<get>> <<set>>
            }
        }

        ' Mouse
        Event <|-- MouseEvent
        ICollectingModule <|.. MouseModule
        MouseEvent <|-- MouseClickEvent
        MouseEvent <|-- MouseScrollEvent
        MouseEvent <|-- MouseMoveEvent
        MouseClickEvent --> "Button" MouseButton
        MouseClickEvent --> "State" MouseButtonState
        !endsub

        !startsub MODULES_WEBBROWSER
        package "WEBBROWSER" #BFBFBF {
            class WebBrowserModule {
        
            }

            class ButtonClickEvent {
                + Button : string <<get>> <<set>>
                + URL: Uri
            }
            
            class CloseTabEvent {
            }
            
            class FileDownloadEvent {
                + MIMEType : string <<get>> <<set>>
                + FileURL: Uri
            }
            
            class HoverEvent {
                + HoveredElement : string <<get>> <<set>>
            }
            class NavigationEvent {
            }
            
            class OpenTabEvent {
            }
            
            class SwitchTabEvent {
                + NewTabID: Guid
            }
            
            class TextInputEvent {
                + InputtedText : string <<get>> <<set>>
                + Textbox : string <<get>> <<set>>
            }
            
            class TextSelectionEvent {
                + SelectedText : string <<get>> <<set>>
            }
            
            abstract class WebBrowserEvent {
                + TabID: Guid
                + CurrentURL: Uri
            }
        }

        ' WebBrowser
        Event <|-- WebBrowserEvent
        ICollectingModule <|.. WebBrowserModule
        WebBrowserEvent <|-- ButtonClickEvent
        WebBrowserEvent <|-- CloseTabEvent
        WebBrowserEvent <|-- FileDownloadEvent
        WebBrowserEvent <|-- HoverEvent
        WebBrowserEvent <|-- NavigationEvent
        WebBrowserEvent <|-- OpenTabEvent
        WebBrowserEvent <|-- SwitchTabEvent
        WebBrowserEvent <|-- TextInputEvent
        WebBrowserEvent <|-- TextSelectionEvent
        !endsub

        !startsub MODULES_WINDOWMANAGEMENT
        package "WINDOWMANAGEMENT" #BFBFBF {
            class WindowManagementModule {
        
            }

            abstract class WindowEvent {
                + Title : string <<get>> <<set>>
                + ProcessName : string <<get>> <<set>>
            }
            
            class WindowFocusEvent {

            }

            class WindowMovementEvent {
                + OldLocation: Vector2
                + NewLocation: Vector2
            }

            class WindowResizingEvent {
                + OldSize: Size
                + NewSize: Size
            }

            class WindowStateChangedEvent {
                + State: WindowState
            }
        }

        ' WindowManagement
        Event <|-- WindowEvent
        ICollectingModule <|.. WindowManagementModule
        WindowEvent <|-- WindowFocusEvent
        WindowEvent <|-- WindowMovementEvent
        WindowEvent <|-- WindowResizingEvent
        WindowEvent <|-- WindowStateChangedEvent
        !endsub
    }

    ' Exceptions
    !startsub EXCEPTIONS

    IEncoder ..> VideoEncodingException : throws >
    IEncoder ..> MetadataEncodingException : throws >

    IDecoder ..> VideoDecodingException : throws >
    IDecoder ..> MetadataDecodingException : throws >
    !endsub
}
@enduml
