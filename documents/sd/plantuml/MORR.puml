@startuml MORR
skinparam monochrome true
skinparam linetype ortho
skinparam classAttributeIconSize 0

left to right direction
hide empty fields

package "MORR" {
    !startsub SHARED
    package "SHARED" #E6E6E6 {
        interface IConfiguration {
            + Parse(configuration:string) : void
        }

        abstract class Event {
            + Timestamp : DateTime
            + IssuingModule : Guid
            + Serialize() : string
            + Deserialize(string serialized) : void
        }

        interface IModule {
            + Identifier : Guid
            + IsEnabled : bool <<get>> <<set>>
            + Initialize() : void
        }

        interface ICollectingModule {    
        }

        interface IReceivingModule {     
        }

        interface ITransformingModule {  
        }

        abstract class "EventQueue<T> where T : Event" {
            + StorageStrategy : IEventQueueStorageStrategy<T> <<get>> <<set>>
            + {abstract} GetEvents() : IAsyncEnumerable<T>
            # {abstract} Enqueue(T @event) : void
        }

        interface "IReadOnlyEventQueue<out T> where T : Event" {
            + GetEvents() : IAsyncEnumerable<T>
        }

        interface "IEventQueueStorageStrategy<T> where T : Event" {
            + GetEvents() : IAsyncEnumerable<T>
            + Enqueue(T @event) : void
        }

        class "KeepAllStorageStrategy<T> where T : Event" {
            + GetEvents() : IAsyncEnumerable<T>
            + Enqueue(T @event) : void
        }
        class "RefCountedListStorageStrategy<T> where T : Event" {
            + GetEvents() : IAsyncEnumerable<T>
            + Enqueue(T @event) : void
        }
        class "RingBufferStorageStrategy<T> where T : Event" {
            + Capacity : uint <<get>> <<set>>
            + GetEvents() : IAsyncEnumerable<T>
            + Enqueue(T @event) : void
        }
    }

    ' EventQueue
    "IReadOnlyEventQueue<out T> where T : Event" <|-- "EventQueue<T> where T : Event"
    "IEventQueueStorageStrategy<T> where T : Event" <|-- "KeepAllStorageStrategy<T> where T : Event"
    "IEventQueueStorageStrategy<T> where T : Event" <|-- "RefCountedListStorageStrategy<T> where T : Event"
    "IEventQueueStorageStrategy<T> where T : Event" <|-- "RingBufferStorageStrategy<T> where T : Event"
    "EventQueue<T> where T : Event" --> "IEventQueueStorageStrategy<T> where T : Event"

    ' Modules
    IModule <|.. ICollectingModule
    IModule <|.. IReceivingModule
    IModule <|.. ITransformingModule
    !endsub 

    !startsub CORE
    package "CORE" #E6E6E6 {
        interface IRecordingManager {
            + IsRecording : bool <<get>>
            + StartRecording() : void
            + StopRecording() : void
            + StartDecoding() : void
            + StopDecoding() : void
        }

        class RecordingManager {
            - encoder : IEncoder
            - decoder : IDecoder
            - videoCapture : IVideoCapture
            + IsRecording : bool <<get>> <<private set>>
            + EventQueues : IEnumerable<EventQueue<Event>> <<get>> <<private set>>
            + StartRecording() : void
            + StopRecording() : void
            + StartDecoding() : void
            + StopDecoding() : void
        }

        interface IModuleManager {
            + Modules : IEnumerable<IModule> <<get>>
            + CollectingModules : IEnumerable<ICollectingModule> <<get>>
            + ModuleConfiguration : GlobalModuleConfiguration <<get>>
            + InitializeModules() : void
        }

        class ModuleManager {
            + Modules : IEnumerable<IModule> <<get>> <<private set>>
            + CollectingModules : IEnumerable<ICollectingModule> <<get>> <<private set>>
            + ModuleConfiguration : GlobalModuleConfiguration <<get>> <<private set>>
            + InitializeModules() : void
        }

        interface IBootstrapper {
            + ComposeImports(@object:object) : void
        }

        class Bootstrapper {
            + ComposeImports(@object:object) : void
        }

        interface IConfigurationManager {
            + LoadConfiguration(path:string) : void
            + Configurations : IEnumerable<IConfiguration> <<get>>
        }

        class ConfigurationManager {
            + LoadConfiguration(path:string) : void
            + Configurations : IEnumerable<IConfiguration> <<get>> <<private set>>
        }

        class GlobalModuleConfiguration {
            + EnabledModules : IEnumerable<Type> <<get>> <<set>>
            + Parse(string configuration) : void
        }

        class RecordingException {
        }

        class InvalidConfigurationException {
        }

        class AlreadyRecordingException {
        }

        class NotRecordingException {
        }

        package "CAPTURE" #BFBFBF {
            interface IVideoCapture {
                + NextSample() : VideoSample
            }

            class DesktopCapture {
                + CaptureConfiguration : DesktopCaptureConfiguration <<get>> <<set>>
                + NextSample() : VideoSample
            }

            class DesktopCaptureConfiguration {
                + DeviceToRecord : string <<get>> <<set>>
                + Parse(string configuration) : void
            }

            class CaptureHelper {
                + {static} CanCreateItemWithoutPicker : bool
                + {static} CreateItemForMonitor(IntPtr hMon) : GraphicsCaptureItem
            }

            class Direct3D11Helper {
                + {static} CreateDevice(bool useWARP = false) : IDirect3DDevice
                + {static} CreateDirect3DSurfaceFromSharpDXTexture(Texture2D texture) : IDirect3DSurface
                + {static} CreatesharpDXDevice(IDirect3DDevice device) : Device
                + {static} CreateSharpDXTexture2D(IDirect3DSurface surface) : Texture2D
            }

            class MonitorInfo {
                + IsPrimary : bool <<get>> <<set>>
                + ScreenSize : Vector2 <<get>> <<set>>
                + MonitorArea : Rect <<get>> <<set>>
                + WorkArea : Rect <<get>> <<set>>
                + DeviceName : string <<get>> <<set>>
                + HMon : IntPtr <<get>> <<set>>
            }

            class MonitorEnumerationHelper {
                + {static} GetMonitors() : IEnumerable<MonitorInfo>
            }

            class CaptureException {
            }

            class VideoCaptureException {
            }

            interface IMetadataCapture {
                + NextSample() : MetadataSample
            }

            class MetadataCapture {
                + EventQueues : IEnumerable<EventQueue<Event>> <<get>> <<private set>>
                + NextSample() : MetadataSample
            }
        }

        package "TRANSCODING" #BFBFBF {
            package "MPEG" #8F8F8F {
                class MPEGDecoder {
                    + Decode(string path) : void <<throws DecodingException>>
                    + DecoderConfiguration : MPEGDecoderConfiguration <<get>> <<set>>
                    + <<event>> VideoSampleDecoded : VideoSampleDecodedEventHandler 
                    + <<event>> MetadataSampleDecoded : MetadataSampleDecodedEventHandler 
                }

                class MPEGDecoderConfiguration {
                    + ShouldExtractVideo : bool <<get>> <<set>>
                    + Parse(string configuration) : void
                }

                class MPEGEncoder {
                    + Encode() : void <<throws EncodingException>>
                    + EncoderConfiguration : MPEGEncoderConfiguration <<get>> <<set>>
                    + <<event>> VideoSampleRequested : VideoSampleRequestedEventHandler 
                    + <<event>> MetadataSampleRequested : MetadataSampleRequestedEventHandler 
                }

                class MPEGEncoderConfiguration {
                    + Bitrate : ushort <<get>> <<set>>
                    + Framerate : byte <<get>> <<set>>
                    + Resolution : Size <<get>> <<set>>
                    + Directory : string <<get>> <<set>>
                    + Parse(string configuration) : void
                }
            }

            package "CSV" #8F8F8F {
                class CSVEncoder {
                    + Encode() : void <<throws EncodingException>>
                    + <<event>> MetadataSampleRequested : MetadataSampleRequestedEventHandler 
                }
            } 

            abstract class MetadataSample {
            }

            abstract class VideoSample {
            }

            class VideoDecodingException {
            }

            class MetadataDecodingException {
            }

            class VideoEncodingException {
            }

            class MetadataEncodingException {
            }

            class DecodingException {
            }

            class EncodingException {
            }

            "Func<VideoSample, void>" <|-- VideoSampleDecodedEventHandler

            "Func<VideoSample?>" <|-- VideoSampleRequestedEventHandler

            "Func<MetadataSample, void>" <|-- MetadataSampleDecodedEventHandler

            "Func<MetadataSample?>" <|-- MetadataSampleRequestedEventHandler

            interface IMetadataDeserializer {
            }

            class MetadataDeserializer {
                + EventQueues : IEnumerable<EventQueue<Event>> <<get>> <<private set>>
            }

            interface IDecoder {
                + Decode(string path) : void <<throws DecodingException>>
                + <<event>> VideoSampleDecoded : VideoSampleDecodedEventHandler 
                + <<event>> MetadataSampleDecoded : MetadataSampleDecodedEventHandler 
            }
        
            interface IEncoder {
                + Encode(string path) : void <<throws EncodingException>>
                + <<event>> VideoSampleRequested : VideoSampleRequestedEventHandler 
                + <<event>> MetadataSampleRequested : MetadataSampleRequestedEventHandler 
            }

            class DecodingException {
            }

            class EncodingException {
            }
        }
    }

    ' CORE

    Exception <|-- RecordingException
    RecordingException <|-- AlreadyRecordingException
    RecordingException <|-- NotRecordingException

    Exception <|-- InvalidConfigurationException
    IBootstrapper <|-- Bootstrapper

    IConfigurationManager <|.. ConfigurationManager
    IConfiguration <|.. GlobalModuleConfiguration
    IModuleManager <|.. ModuleManager
    IRecordingManager <|.. RecordingManager

    Exception <|.. CaptureException

    IVideoCapture <|.. DesktopCapture
    IConfiguration <|.. DesktopCaptureConfiguration

    CaptureException <|-- VideoCaptureException

    IReceivingModule <|.. IMetadataCapture
    IMetadataCapture <|.. MetadataCapture

    IEncoder <|.. CSVEncoder

    Exception <|-- DecodingException
    Exception <|-- EncodingException

    DecodingException <|-- MetadataDecodingException
    EncodingException <|-- MetadataEncodingException

    IMetadataDeserializer <|.. MetadataDeserializer

    DecodingException <|-- VideoDecodingException
    EncodingException <|-- VideoEncodingException

    IDecoder <|.. MPEGDecoder
    IEncoder <|.. MPEGEncoder

    IConfiguration <|.. MPEGDecoderConfiguration
    IConfiguration <|.. MPEGEncoderConfiguration

    ConfigurationManager --> "*" IConfiguration
    ConfigurationManager --> InvalidConfigurationException : throws
    ModuleManager --> "*" IModule
    ModuleManager --> "*" ICollectingModule

    RecordingManager --> "encoder" IEncoder
    RecordingManager --> "decoder" IDecoder
    RecordingManager --> "videoCapture" DesktopCapture
    RecordingManager --> "metadataCapture" MetadataCapture
    RecordingManager --> "metadataDeserializer" MetadataDeserializer
    RecordingManager --> "ConfigurationManager" ConfigurationManager
    RecordingManager --> "ModuleManager" ModuleManager
    RecordingManager ..> IBootstrapper : uses

    ' Transcoding
    IDecoder ..> MetadataSample : uses
    IEncoder ..> MetadataSample : uses
    IVideoCapture ..> VideoSample : <<creates>>
    IVideoCapture ..> VideoCaptureException : throws >

    ' MPEG
    DesktopCapture ..> Direct3D11Helper : uses
    DesktopCapture ..> CaptureHelper : uses

    MPEGEncoder ..> DesktopCapture : uses
    MPEGEncoder ..> MonitorEnumerationHelper : uses
    MonitorEnumerationHelper ..> MonitorInfo : uses
    !endsub

    !startsub UI
    package "UI" #E6E6E6 {
        class ErrorDialog <<partial>> {
            + ErrorDialog(errorMessage:string)
            + ErrorMessage : string <<get>>
        }

        class InformationDialog <<partial>> {
            + InformationDialog()
        }

        class SaveDialog <<partial>> {
            + SaveDialog()
        }

        class ApplicationViewModel {
            + ApplicationViewModel()
            + IsRecording : bool <<get>> <<set>>
        }
        
        class NotifyIcon {
            + NotifyIcon()
            + Tooltip : string <<get>> <<set>>
            + CommandParameter : object <<get>> <<set>>
        }
        
        class RelayCommand {
            + RelayCommand(execute:Action<object>, canExecute:Predicate<object>?)
            + CanExecute(parameter:object) : bool
            + Execute(parameter:object) : void
        }

        interface ICommand {

        }

        class ContextMenu {

        }

        class ImageSource {

        }

        class App <<partial>> {

        }        
    }

    ' UI
    ApplicationViewModel --> "1" IRecordingManager : uses
    ApplicationViewModel o--> "n" ICommand
    App --> "1" ApplicationViewModel
    ApplicationViewModel o-> SaveDialog
    ApplicationViewModel o-> ErrorDialog
    ApplicationViewModel o-> InformationDialog
    App o-> NotifyIcon
    NotifyIcon --> "IconSource" ImageSource
    NotifyIcon --> "Command" ICommand
    NotifyIcon --> "ContextMenu" ContextMenu
    ICommand <|.. RelayCommand
    !endsub

    !startsub CLI
    package "CLI" #E6E6E6 {
        class Program {
            {static} Main(args:string[]) : void
        }
        
        class Options {

        }

        interface ICLICommand {
            + ExecuteCommand(options: Options)
        }

        class ProcessOptions {
            + Input : string
            + Output : string
            + ProcessingEnabled: bool
            + Verbose: bool
        }
    
        class OutputFormatter {
            + PrintMessage(message: string, verbose: bool) : void
            + PrintException(exception: Exception) : void
        }
    
        class ProcessCommand {
            + ProcessCommand(recordingManager : IRecordingManager)
            + ExecuteCommand(options: ProcessOptions)
        }
    }

    ' CLI
    IRecordingManager <-- ProcessCommand
    Program --> IRecordingManager

    Program --> "1" OutputFormatter
    Program o--> ICLICommand
    ICLICommand ..> Options : uses
    ICLICommand <|.. ProcessCommand
    Options <|-- ProcessOptions
    ProcessCommand ..> ProcessOptions: uses
    !endsub

    package "MODULES" #E6E6E6 {
        !startsub MODULES_CLIPBOARD
        package "CLIPBOARD" #BFBFBF {
            class ClipboardModule {
            
            }

            abstract class ClipboardEvent {
            
            }

            class ClipBoardInteractEvent {
                + Text : string <<get>> <<set>>
            }

            enum InteractionType {
                CLEAR
                COPY
                CUT
                PASTE
            }
        }

        'Clipboard
        ICollectingModule <|.. ClipboardModule
        Event <|-- ClipboardEvent
        ClipboardEvent <|-- ClipBoardInteractEvent
        ClipBoardInteractEvent --> "Interaction" InteractionType
        ClipBoardInteractEvent +-- InteractionType
        !endsub

        !startsub MODULES_KEYBOARD
        package "KEYBOARD" #BFBFBF {
            class KeyboardModule {
            
            }

            abstract class KeyboardEvent {
            }
            
            class KeyBoardInteractEvent {
                + PressedKey: Key
            }
        }

        ' Keyboard
        Event <|-- KeyboardEvent
        ICollectingModule <|.. KeyboardModule
        KeyboardEvent <|-- KeyBoardInteractEvent
        !endsub

        !startsub MODULES_MOUSE
        package "MOUSE" #BFBFBF {
            class MouseModule {
        
            }

            
            abstract class MouseEvent {
            }

            class MouseMoveEvent {
                + Movement: Vector2
            }

            enum MouseButton {
                LEFT,
                CENTER,
                RIGHT
            }

            enum MouseButtonState {

            }
            
            class MouseClickEvent {
                + HWnd: IntPtr
            }
            
            class MouseScrollEvent {
                + HWnd: IntPtr
                + ScrollAmount : short <<get>> <<set>>
            }
        }

        ' Mouse
        Event <|-- MouseEvent
        ICollectingModule <|.. MouseModule
        MouseEvent <|-- MouseClickEvent
        MouseEvent <|-- MouseScrollEvent
        MouseEvent <|-- MouseMoveEvent
        MouseClickEvent --> "Button" MouseButton
        MouseClickEvent --> "State" MouseButtonState
        !endsub

        !startsub MODULES_WEBBROWSER
        package "WEBBROWSER" #BFBFBF {
            class WebBrowserModule {
        
            }

            class ButtonClickEvent {
                + Button : string <<get>> <<set>>
                + URL: Uri
            }
            
            class CloseTabEvent {
            }
            
            class FileDownloadEvent {
                + MIMEType : string <<get>> <<set>>
                + FileURL: Uri
            }
            
            class HoverEvent {
                + HoveredElement : string <<get>> <<set>>
            }
            class NavigationEvent {
            }
            
            class OpenTabEvent {
            }
            
            class SwitchTabEvent {
                + NewTabID: Guid
            }
            
            class TextInputEvent {
                + InputtedText : string <<get>> <<set>>
                + Textbox : string <<get>> <<set>>
            }
            
            class TextSelectionEvent {
                + SelectedText : string <<get>> <<set>>
            }
            
            abstract class WebBrowserEvent {
                + TabID: Guid
                + CurrentURL: Uri
            }
        }

        ' WebBrowser
        Event <|-- WebBrowserEvent
        ICollectingModule <|.. WebBrowserModule
        WebBrowserEvent <|-- ButtonClickEvent
        WebBrowserEvent <|-- CloseTabEvent
        WebBrowserEvent <|-- FileDownloadEvent
        WebBrowserEvent <|-- HoverEvent
        WebBrowserEvent <|-- NavigationEvent
        WebBrowserEvent <|-- OpenTabEvent
        WebBrowserEvent <|-- SwitchTabEvent
        WebBrowserEvent <|-- TextInputEvent
        WebBrowserEvent <|-- TextSelectionEvent
        !endsub

        !startsub MODULES_WINDOWMANAGEMENT
        package "WINDOWMANAGEMENT" #BFBFBF {
            class WindowManagementModule {
        
            }

            abstract class WindowEvent {
                + Title : string <<get>> <<set>>
                + ProcessName : string <<get>> <<set>>
            }
            
            class WindowFocusEvent {

            }

            class WindowMovementEvent {
                + OldLocation: Vector2
                + NewLocation: Vector2
            }

            class WindowResizingEvent {
                + OldSize: Size
                + NewSize: Size
            }

            class WindowStateChangedEvent {
                + State: WindowState
            }
        }

        ' WindowManagement
        Event <|-- WindowEvent
        ICollectingModule <|.. WindowManagementModule
        WindowEvent <|-- WindowFocusEvent
        WindowEvent <|-- WindowMovementEvent
        WindowEvent <|-- WindowResizingEvent
        WindowEvent <|-- WindowStateChangedEvent
        !endsub
    }

    ' Exceptions
    !startsub EXCEPTIONS

    IEncoder ..> VideoEncodingException : throws >
    IEncoder ..> MetadataEncodingException : throws >

    IDecoder ..> VideoDecodingException : throws >
    IDecoder ..> MetadataDecodingException : throws >
    !endsub
}
@enduml
